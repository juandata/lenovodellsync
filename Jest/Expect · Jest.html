
<!-- saved from url=(0051)https://facebook.github.io/jest/docs/en/expect.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Expect · Jest</title><meta name="viewport" content="width=device-width"><meta name="generator" content="Docusaurus"><meta property="og:title" content="Expect · Jest"><meta property="og:type" content="website"><meta property="og:url" content="https://facebook.github.io/jest/index.html"><meta property="og:description" content="When you&#39;re writing tests, you often need to check that values meet certain"><meta property="og:image" content="https://facebook.github.io/jest/img/opengraph.png"><link rel="shortcut icon" href="https://facebook.github.io/jest/img/favicon/favicon.ico"><link rel="stylesheet" href="./Expect · Jest_files/docsearch.min.css"><link rel="stylesheet" href="./Expect · Jest_files/default.min.css"><link rel="alternate" type="application/atom+xml" href="https://facebook.github.io/blog/atom.xml" title="Jest Blog ATOM Feed"><link rel="alternate" type="application/rss+xml" href="https://facebook.github.io/blog/feed.xml" title="Jest Blog RSS Feed"><script type="text/javascript" src="./Expect · Jest_files/buttons.js.download"></script><link rel="stylesheet" href="./Expect · Jest_files/main.css"></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="https://facebook.github.io/jest/"><img class="logo" src="./Expect · Jest_files/jest.svg"><h2 class="headerTitle">Jest</h2></a><a href="https://facebook.github.io/jest/en/versions.html"><h3>22.4</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="https://facebook.github.io/jest/docs/en/getting-started.html" target="_self">Docs</a></li><li><a href="https://facebook.github.io/jest/docs/en/api.html" target="_self">API</a></li><li><a href="https://facebook.github.io/jest/en/help.html" target="_self">Help</a></li><li><a href="https://facebook.github.io/jest/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="https://facebook.github.io/jest/docs/en/expect.html#"><img class="languages-icon" src="./Expect · Jest_files/language.svg">English</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="https://facebook.github.io/jest/en">English</a></li><li><a href="https://facebook.github.io/jest/ja">日本語</a></li><li><a href="https://facebook.github.io/jest/es-ES">Español</a></li><li><a href="https://facebook.github.io/jest/pt-BR">Português (Brasil)</a></li><li><a href="https://facebook.github.io/jest/ro">Română</a></li><li><a href="https://facebook.github.io/jest/ru">Русский</a></li><li><a href="https://facebook.github.io/jest/uk">Українська</a></li><li><a href="https://facebook.github.io/jest/zh-Hans">简体中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"></li><li><a href="https://github.com/facebook/jest" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>API Reference</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Introduction</h3><ul><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/getting-started.html">Getting Started</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/using-matchers.html">Using Matchers</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/asynchronous.html">Testing Asynchronous Code</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/setup-teardown.html">Setup and Teardown</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/mock-functions.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/jest-platform.html">Jest Platform</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/jest-community.html">Jest Community</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/more-resources.html">More Resources</a></li></ul></div><div class="navGroup navGroupActive"><h3>Guides</h3><ul><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/snapshot-testing.html">Snapshot Testing</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/tutorial-async.html">An Async Example</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/timer-mocks.html">Timer Mocks</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/manual-mocks.html">Manual Mocks</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/es6-class-mocks.html">ES6 Class Mocks</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/webpack.html">Using with webpack</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/puppeteer.html">Using with puppeteer</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/mongodb.html">Using with MongoDB</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/migration-guide.html">Migrating to Jest</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/troubleshooting.html">Troubleshooting</a></li></ul></div><div class="navGroup navGroupActive"><h3>Framework Guides</h3><ul><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/tutorial-react.html">Testing React Apps</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/tutorial-react-native.html">Testing React Native Apps</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/testing-frameworks.html">Testing Web Frameworks</a></li></ul></div><div class="navGroup navGroupActive"><h3>API Reference</h3><ul><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/api.html">Globals</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="https://facebook.github.io/jest/docs/en/expect.html">Expect</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/mock-function-api.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/jest-object.html">The Jest Object</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/configuration.html">Configuring Jest</a></li><li class="navListItem"><a class="navItem" href="https://facebook.github.io/jest/docs/en/cli.html">Jest CLI Options</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/facebook/jest/edit/master/docs/ExpectAPI.md" target="_blank">Edit</a><h1>Expect</h1></header><article><div><span><p>When you're writing tests, you often need to check that values meet certain
conditions. <code>expect</code> gives you access to a number of "matchers" that let you
validate different things.</p>
<h2><a class="anchor" aria-hidden="true" name="methods"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#methods" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Methods</h2>
<ul>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#expectvalue"><code>expect(value)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#expectextendmatchers"><code>expect.extend(matchers)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#expectanything"><code>expect.anything()</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#expectanyconstructor"><code>expect.any(constructor)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#expectarraycontainingarray"><code>expect.arrayContaining(array)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#expectassertionsnumber"><code>expect.assertions(number)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#expecthasassertions"><code>expect.hasAssertions()</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#expectnotarraycontainingarray"><code>expect.not.arrayContaining(array)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#expectnotobjectcontainingobject"><code>expect.not.objectContaining(object)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#expectnotstringcontainingstring"><code>expect.not.stringContaining(string)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#expectnotstringmatchingregexp"><code>expect.not.stringMatching(regexp)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#expectobjectcontainingobject"><code>expect.objectContaining(object)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#expectstringcontainingstring"><code>expect.stringContaining(string)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#expectstringmatchingregexp"><code>expect.stringMatching(regexp)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#expectaddsnapshotserializerserializer"><code>expect.addSnapshotSerializer(serializer)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#not"><code>.not</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#resolves"><code>.resolves</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#rejects"><code>.rejects</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tobevalue"><code>.toBe(value)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tohavebeencalled"><code>.toHaveBeenCalled()</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tohavebeencalledtimesnumber"><code>.toHaveBeenCalledTimes(number)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tohavebeencalledwitharg1-arg2-"><code>.toHaveBeenCalledWith(arg1, arg2, ...)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tohavebeenlastcalledwitharg1-arg2-"><code>.toHaveBeenLastCalledWith(arg1, arg2, ...)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tobeclosetonumber-numdigits"><code>.toBeCloseTo(number, numDigits)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tobedefined"><code>.toBeDefined()</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tobefalsy"><code>.toBeFalsy()</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tobegreaterthannumber"><code>.toBeGreaterThan(number)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tobegreaterthanorequalnumber"><code>.toBeGreaterThanOrEqual(number)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tobelessthannumber"><code>.toBeLessThan(number)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tobelessthanorequalnumber"><code>.toBeLessThanOrEqual(number)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tobeinstanceofclass"><code>.toBeInstanceOf(Class)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tobenull"><code>.toBeNull()</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tobetruthy"><code>.toBeTruthy()</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tobeundefined"><code>.toBeUndefined()</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tocontainitem"><code>.toContain(item)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tocontainequalitem"><code>.toContainEqual(item)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#toequalvalue"><code>.toEqual(value)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tohavelengthnumber"><code>.toHaveLength(number)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tomatchregexporstring"><code>.toMatch(regexpOrString)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tomatchobjectobject"><code>.toMatchObject(object)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tohavepropertykeypath-value"><code>.toHaveProperty(keyPath, value)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tomatchsnapshotoptionalstring"><code>.toMatchSnapshot(optionalString)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tothrowerror"><code>.toThrow(error)</code></a></li>
<li><a href="https://facebook.github.io/jest/docs/en/expect.html#tothrowerrormatchingsnapshot"><code>.toThrowErrorMatchingSnapshot()</code></a></li>
</ul>
<hr>
<h2><a class="anchor" aria-hidden="true" name="reference"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#reference" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reference</h2>
<h3><a class="anchor" aria-hidden="true" name="expectvalue"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#expectvalue" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect(value)</code></h3>
<p>The <code>expect</code> function is used every time you want to test a value. You will
rarely call <code>expect</code> by itself. Instead, you will use <code>expect</code> along with a
"matcher" function to assert something about a value.</p>
<p>It's easier to understand this with an example. Let's say you have a method
<code>bestLaCroixFlavor()</code> which is supposed to return the string <code>'grapefruit'</code>.
Here's how you would test that:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'the best flavor is grapefruit'</span>, () =&gt; {
  expect(bestLaCroixFlavor()).toBe(<span class="hljs-string">'grapefruit'</span>);
});
</code></pre>
<p>In this case, <code>toBe</code> is the matcher function. There are a lot of different
matcher functions, documented below, to help you test different things.</p>
<p>The argument to <code>expect</code> should be the value that your code produces, and any
argument to the matcher should be the correct value. If you mix them up, your
tests will still work, but the error messages on failing tests will look
strange.</p>
<h3><a class="anchor" aria-hidden="true" name="expectextendmatchers"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#expectextendmatchers" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.extend(matchers)</code></h3>
<p>You can use <code>expect.extend</code> to add your own matchers to Jest. For example, let's
say that you're testing a number theory library and you're frequently asserting
that numbers are divisible by other numbers. You could abstract that into a
<code>toBeDivisibleBy</code> matcher:</p>
<pre><code class="hljs css js">expect.extend({
  toBeDivisibleBy(received, argument) {
    <span class="hljs-keyword">const</span> pass = received % argument == <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (pass) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
          <span class="hljs-string">`expected <span class="hljs-subst">${received}</span> not to be divisible by <span class="hljs-subst">${argument}</span>`</span>,
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">true</span>,
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">`expected <span class="hljs-subst">${received}</span> to be divisible by <span class="hljs-subst">${argument}</span>`</span>,
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">false</span>,
      };
    }
  },
});

test(<span class="hljs-string">'even and odd numbers'</span>, () =&gt; {
  expect(<span class="hljs-number">100</span>).toBeDivisibleBy(<span class="hljs-number">2</span>);
  expect(<span class="hljs-number">101</span>).not.toBeDivisibleBy(<span class="hljs-number">2</span>);
});
</code></pre>
<p>Matchers should return an object with two keys. <code>pass</code> indicates whether there
was a match or not, and <code>message</code> provides a function with no arguments that
returns an error message in case of failure. Thus, when <code>pass</code> is false,
<code>message</code> should return the error message for when <code>expect(x).yourMatcher()</code>
fails. And when <code>pass</code> is true, <code>message</code> should return the error message for
when <code>expect(x).not.yourMatcher()</code> fails.</p>
<p>These helper functions can be found on <code>this</code> inside a custom matcher:</p>
<h4><a class="anchor" aria-hidden="true" name="thisisnot"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#thisisnot" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>this.isNot</code></h4>
<p>A boolean to let you know this matcher was called with the negated <code>.not</code>
modifier allowing you to flip your assertion.</p>
<h4><a class="anchor" aria-hidden="true" name="thisequalsa-b"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#thisequalsa-b" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>this.equals(a, b)</code></h4>
<p>This is a deep-equality function that will return <code>true</code> if two objects have the
same values (recursively).</p>
<h4><a class="anchor" aria-hidden="true" name="thisutils"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#thisutils" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>this.utils</code></h4>
<p>There are a number of helpful tools exposed on <code>this.utils</code> primarily consisting
of the exports from
<a href="https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils"><code>jest-matcher-utils</code></a>.</p>
<p>The most useful ones are <code>matcherHint</code>, <code>printExpected</code> and <code>printReceived</code> to
format the error messages nicely. For example, take a look at the implementation
for the <code>toBe</code> matcher:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">const</span> diff = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jest-diff'</span>);
expect.extend({
  toBe(received, expected) {
    <span class="hljs-keyword">const</span> pass = <span class="hljs-built_in">Object</span>.is(received, expected);

    <span class="hljs-keyword">const</span> message = pass
      ? <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
          <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'.not.toBe'</span>) +
          <span class="hljs-string">'\n\n'</span> +
          <span class="hljs-string">`Expected value to not be (using Object.is):\n`</span> +
          <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
          <span class="hljs-string">`Received:\n`</span> +
          <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span>
      : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
          <span class="hljs-keyword">const</span> diffString = diff(expected, received, {
            <span class="hljs-attr">expand</span>: <span class="hljs-keyword">this</span>.expand,
          });
          <span class="hljs-keyword">return</span> (
            <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'.toBe'</span>) +
            <span class="hljs-string">'\n\n'</span> +
            <span class="hljs-string">`Expected value to be (using Object.is):\n`</span> +
            <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
            <span class="hljs-string">`Received:\n`</span> +
            <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span> +
            (diffString ? <span class="hljs-string">`\n\nDifference:\n\n<span class="hljs-subst">${diffString}</span>`</span> : <span class="hljs-string">''</span>)
          );
        };

    <span class="hljs-keyword">return</span> {<span class="hljs-attr">actual</span>: received, message, pass};
  },
});
</code></pre>
<p>This will print something like this:</p>
<pre><code class="hljs css bash">  expect(received).toBe(expected)

    Expected value to be (using Object.is):
      <span class="hljs-string">"banana"</span>
    Received:
      <span class="hljs-string">"apple"</span>
</code></pre>
<p>When an assertion fails, the error message should give as much signal as
necessary to the user so they can resolve their issue quickly. You should craft
a precise failure message to make sure users of your custom assertions have a
good developer experience.</p>
<h3><a class="anchor" aria-hidden="true" name="expectanything"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#expectanything" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.anything()</code></h3>
<p><code>expect.anything()</code> matches anything but <code>null</code> or <code>undefined</code>. You can use it
inside <code>toEqual</code> or <code>toBeCalledWith</code> instead of a literal value. For example, if
you want to check that a mock function is called with a non-null argument:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'map calls its argument with a non-null argument'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  [<span class="hljs-number">1</span>].map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> mock(x));
  expect(mock).toBeCalledWith(expect.anything());
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="expectanyconstructor"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#expectanyconstructor" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.any(constructor)</code></h3>
<p><code>expect.any(constructor)</code> matches anything that was created with the given
constructor. You can use it inside <code>toEqual</code> or <code>toBeCalledWith</code> instead of a
literal value. For example, if you want to check that a mock function is called
with a number:</p>
<pre><code class="hljs css js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randocall</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> fn(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">6</span> + <span class="hljs-number">1</span>));
}

test(<span class="hljs-string">'randocall calls its callback with a number'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  randocall(mock);
  expect(mock).toBeCalledWith(expect.any(<span class="hljs-built_in">Number</span>));
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="expectarraycontainingarray"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#expectarraycontainingarray" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.arrayContaining(array)</code></h3>
<p><code>expect.arrayContaining(array)</code> matches a received array which contains all of
the elements in the expected array. That is, the expected array is a <strong>subset</strong>
of the received array. Therefore, it matches a received array which contains
elements that are <strong>not</strong> in the expected array.</p>
<p>You can use it instead of a literal value:</p>
<ul>
<li>in <code>toEqual</code> or <code>toBeCalledWith</code></li>
<li>to match a property in <code>objectContaining</code> or <code>toMatchObject</code></li>
</ul>
<pre><code class="hljs css js">describe(<span class="hljs-string">'arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>];
  it(<span class="hljs-string">'matches even if received contains additional elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match if received does not contain expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<pre><code class="hljs css js">describe(<span class="hljs-string">'Beware of a misunderstanding! A sequence of dice rolls'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
  it(<span class="hljs-string">'matches even with an unexpected number 7'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]).toEqual(
      expect.arrayContaining(expected),
    );
  });
  it(<span class="hljs-string">'does not match without an expected number 2'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]).not.toEqual(
      expect.arrayContaining(expected),
    );
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="expectassertionsnumber"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#expectassertionsnumber" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.assertions(number)</code></h3>
<p><code>expect.assertions(number)</code> verifies that a certain number of assertions are
called during a test. This is often useful when testing asynchronous code, in
order to make sure that assertions in a callback actually got called.</p>
<p>For example, let's say that we have a function <code>doAsync</code> that receives two
callbacks <code>callback1</code> and <code>callback2</code>, it will asynchronously call both of them
in an unknown order. We can test this with:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'doAsync calls both callbacks'</span>, () =&gt; {
  expect.assertions(<span class="hljs-number">2</span>);
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback1</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback2</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }

  doAsync(callback1, callback2);
});
</code></pre>
<p>The <code>expect.assertions(2)</code> call ensures that both callbacks actually get called.</p>
<h3><a class="anchor" aria-hidden="true" name="expecthasassertions"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#expecthasassertions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.hasAssertions()</code></h3>
<p><code>expect.hasAssertions()</code> verifies that at least one assertion is called during a
test. This is often useful when testing asynchronous code, in order to make sure
that assertions in a callback actually got called.</p>
<p>For example, let's say that we have a few functions that all deal with state.
<code>prepareState</code> calls a callback with a state object, <code>validateState</code> runs on
that state object, and <code>waitOnState</code> returns a promise that waits until all
<code>prepareState</code> callbacks complete. We can test this with:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'prepareState prepares a valid state'</span>, () =&gt; {
  expect.hasAssertions();
  prepareState(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> {
    expect(validateState(state)).toBeTruthy();
  });
  <span class="hljs-keyword">return</span> waitOnState();
});
</code></pre>
<p>The <code>expect.hasAssertions()</code> call ensures that the <code>prepareState</code> callback
actually gets called.</p>
<h3><a class="anchor" aria-hidden="true" name="expectnotarraycontainingarray"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#expectnotarraycontainingarray" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.not.arrayContaining(array)</code></h3>
<p><code>expect.not.arrayContaining(array)</code> matches a received array which contains none
of the elements in the expected array. That is, the expected array <strong>is not a
subset</strong> of the received array.</p>
<p>It is the inverse of <code>expect.arrayContaining</code>.</p>
<pre><code class="hljs css js">describe(<span class="hljs-string">'not.arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-string">'Samantha'</span>];

  it(<span class="hljs-string">'matches if the actual array does not contain the expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).toEqual(
      expect.not.arrayContaining(expected),
    );
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="expectnotobjectcontainingobject"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#expectnotobjectcontainingobject" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.not.objectContaining(object)</code></h3>
<p><code>expect.not.objectContaining(object)</code> matches any received object that does not
recursively match the expected properties. That is, the expected object <strong>is not
a subset</strong> of the received object. Therefore, it matches a received object which
contains properties that are <strong>not</strong> in the expected object.</p>
<p>It is the inverse of <code>expect.objectContaining</code>.</p>
<pre><code class="hljs css js">describe(<span class="hljs-string">'not.objectContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = {<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>};

  it(<span class="hljs-string">'matches if the actual object does not contain expected key: value pairs'</span>, () =&gt; {
    expect({<span class="hljs-attr">bar</span>: <span class="hljs-string">'baz'</span>}).toEqual(expect.not.objectContaining(expected));
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="expectnotstringcontainingstring"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#expectnotstringcontainingstring" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.not.stringContaining(string)</code></h3>
<p><code>expect.not.stringContaining(string)</code> matches any received string that does not
contain the exact expected string.</p>
<p>It is the inverse of <code>expect.stringContaining</code>.</p>
<pre><code class="hljs css js">describe(<span class="hljs-string">'not.stringContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = <span class="hljs-string">'Hello world!'</span>;

  it(<span class="hljs-string">'matches if the actual string does not contain the expected substring'</span>, () =&gt; {
    expect(<span class="hljs-string">'How are you?'</span>).toEqual(expect.not.stringContaining(expected));
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="expectnotstringmatchingregexp"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#expectnotstringmatchingregexp" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.not.stringMatching(regexp)</code></h3>
<p><code>expect.not.stringMatching(regexp)</code> matches any received string that does not
match the expected regexp.</p>
<p>It is the inverse of <code>expect.stringMatching</code>.</p>
<pre><code class="hljs css js">describe(<span class="hljs-string">'not.stringMatching'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = <span class="hljs-regexp">/Hello world!/</span>;

  it(<span class="hljs-string">'matches if the actual string does not match the expected regex'</span>, () =&gt; {
    expect(<span class="hljs-string">'How are you?'</span>).toEqual(expect.not.stringMatching(expected));
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="expectobjectcontainingobject"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#expectobjectcontainingobject" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.objectContaining(object)</code></h3>
<p><code>expect.objectContaining(object)</code> matches any received object that recursively
matches the expected properties. That is, the expected object is a <strong>subset</strong> of
the received object. Therefore, it matches a received object which contains
properties that are <strong>not</strong> in the expected object.</p>
<p>Instead of literal property values in the expected object, you can use matchers,
<code>expect.anything()</code>, and so on.</p>
<p>For example, let's say that we expect an <code>onPress</code> function to be called with an
<code>Event</code> object, and all we need to verify is that the event has <code>event.x</code> and
<code>event.y</code> properties. We can do that with:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'onPress gets called with the right thing'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> onPress = jest.fn();
  simulatePresses(onPress);
  expect(onPress).toBeCalledWith(
    expect.objectContaining({
      <span class="hljs-attr">x</span>: expect.any(<span class="hljs-built_in">Number</span>),
      <span class="hljs-attr">y</span>: expect.any(<span class="hljs-built_in">Number</span>),
    }),
  );
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="expectstringcontainingstring"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#expectstringcontainingstring" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.stringContaining(string)</code></h3>
<p><code>expect.stringContaining(string)</code> matches any received string that contains the
exact expected string.</p>
<h3><a class="anchor" aria-hidden="true" name="expectstringmatchingregexp"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#expectstringmatchingregexp" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.stringMatching(regexp)</code></h3>
<p><code>expect.stringMatching(regexp)</code> matches any received string that matches the
expected regexp.</p>
<p>You can use it instead of a literal value:</p>
<ul>
<li>in <code>toEqual</code> or <code>toBeCalledWith</code></li>
<li>to match an element in <code>arrayContaining</code></li>
<li>to match a property in <code>objectContaining</code> or <code>toMatchObject</code></li>
</ul>
<p>This example also shows how you can nest multiple asymmetric matchers, with
<code>expect.stringMatching</code> inside the <code>expect.arrayContaining</code>.</p>
<pre><code class="hljs css js">describe(<span class="hljs-string">'stringMatching in arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [
    expect.stringMatching(<span class="hljs-regexp">/^Alic/</span>),
    expect.stringMatching(<span class="hljs-regexp">/^[BR]ob/</span>),
  ];
  it(<span class="hljs-string">'matches even if received contains additional elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alicia'</span>, <span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>]).toEqual(
      expect.arrayContaining(expected),
    );
  });
  it(<span class="hljs-string">'does not match if received does not contain expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>]).not.toEqual(
      expect.arrayContaining(expected),
    );
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="expectaddsnapshotserializerserializer"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#expectaddsnapshotserializerserializer" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.addSnapshotSerializer(serializer)</code></h3>
<p>You can call <code>expect.addSnapshotSerializer</code> to add a module that formats
application-specific data structures.</p>
<p>For an individual test file, an added module precedes any modules from
<code>snapshotSerializers</code> configuration, which precede the default snapshot
serializers for built-in JavaScript types and for React elements. The last
module added is the first module tested.</p>
<pre><code class="hljs css js"><span class="hljs-keyword">import</span> serializer <span class="hljs-keyword">from</span> <span class="hljs-string">'my-serializer-module'</span>;
expect.addSnapshotSerializer(serializer);

<span class="hljs-comment">// affects expect(value).toMatchSnapshot() assertions in the test file</span>
</code></pre>
<p>If you add a snapshot serializer in individual test files instead of to adding
it to <code>snapshotSerializers</code> configuration:</p>
<ul>
<li>You make the dependency explicit instead of implicit.</li>
<li>You avoid limits to configuration that might cause you to eject from
<a href="https://github.com/facebookincubator/create-react-app">create-react-app</a>.</li>
</ul>
<p>See <a href="https://facebook.github.io/jest/docs/en/configuration.html#snapshotserializers-array-string">configuring Jest</a> for
more information.</p>
<h3><a class="anchor" aria-hidden="true" name="not"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#not" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.not</code></h3>
<p>If you know how to test something, <code>.not</code> lets you test its opposite. For
example, this code tests that the best La Croix flavor is not coconut:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'the best flavor is not coconut'</span>, () =&gt; {
  expect(bestLaCroixFlavor()).not.toBe(<span class="hljs-string">'coconut'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="resolves"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#resolves" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.resolves</code></h3>
<p>Use <code>resolves</code> to unwrap the value of a fulfilled promise so any other matcher
can be chained. If the promise is rejected the assertion fails.</p>
<p>For example, this code tests that the promise resolves and that the resulting
value is <code>'lemon'</code>:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'resolves to lemon'</span>, () =&gt; {
  <span class="hljs-comment">// make sure to add a return statement</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'lemon'</span>)).resolves.toBe(<span class="hljs-string">'lemon'</span>);
});
</code></pre>
<p>Note that, since you are still testing promises, the test is still asynchronous.
Hence, you will need to <a href="https://facebook.github.io/jest/docs/en/asynchronous.html#promises">tell Jest to wait</a> by
returning the unwrapped assertion.</p>
<p>Alternatively, you can use <code>async/await</code> in combination with <code>.resolves</code>:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'resolves to lemon'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'lemon'</span>)).resolves.toBe(<span class="hljs-string">'lemon'</span>);
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'lemon'</span>)).resolves.not.toBe(<span class="hljs-string">'octopus'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="rejects"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#rejects" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.rejects</code></h3>
<p>Use <code>.rejects</code> to unwrap the reason of a rejected promise so any other matcher
can be chained. If the promise is fulfilled the assertion fails.</p>
<p>For example, this code tests that the promise rejects with reason <code>'octopus'</code>:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'rejects to octopus'</span>, () =&gt; {
  <span class="hljs-comment">// make sure to add a return statement</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'octopus'</span>))).rejects.toThrow(
    <span class="hljs-string">'octopus'</span>,
  );
});
</code></pre>
<p>Note that, since you are still testing promises, the test is still asynchronous.
Hence, you will need to <a href="https://facebook.github.io/jest/docs/en/asynchronous.html#promises">tell Jest to wait</a> by
returning the unwrapped assertion.</p>
<p>Alternatively, you can use <code>async/await</code> in combination with <code>.rejects</code>.</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'rejects to octopus'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'octopus'</span>))).rejects.toThrow(<span class="hljs-string">'octopus'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobevalue"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tobevalue" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBe(value)</code></h3>
<p><code>toBe</code> just checks that a value is what you expect. It uses <code>Object.is</code> to check
exact equality.</p>
<p>For example, this code will validate some properties of the <code>can</code> object:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">const</span> can = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'pamplemousse'</span>,
  <span class="hljs-attr">ounces</span>: <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'the can'</span>, () =&gt; {
  test(<span class="hljs-string">'has 12 ounces'</span>, () =&gt; {
    expect(can.ounces).toBe(<span class="hljs-number">12</span>);
  });

  test(<span class="hljs-string">'has a sophisticated name'</span>, () =&gt; {
    expect(can.name).toBe(<span class="hljs-string">'pamplemousse'</span>);
  });
});
</code></pre>
<p>Don't use <code>toBe</code> with floating-point numbers. For example, due to rounding, in
JavaScript <code>0.2 + 0.1</code> is not strictly equal to <code>0.3</code>. If you have floating
point numbers, try <code>.toBeCloseTo</code> instead.</p>
<h3><a class="anchor" aria-hidden="true" name="tohavebeencalled"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tohavebeencalled" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenCalled()</code></h3>
<p>Also under the alias: <code>.toBeCalled()</code></p>
<p>Use <code>.toHaveBeenCalled</code> to ensure that a mock function got called.</p>
<p>For example, let's say you have a <code>drinkAll(drink, flavor)</code> function that takes
a <code>drink</code> function and applies it to all available beverages. You might want to
check that <code>drink</code> gets called for <code>'lemon'</code>, but not for <code>'octopus'</code>, because
<code>'octopus'</code> flavor is really weird and why would anything be octopus-flavored?
You can do that with this test suite:</p>
<pre><code class="hljs css js">describe(<span class="hljs-string">'drinkAll'</span>, () =&gt; {
  test(<span class="hljs-string">'drinks something lemon-flavored'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> drink = jest.fn();
    drinkAll(drink, <span class="hljs-string">'lemon'</span>);
    expect(drink).toHaveBeenCalled();
  });

  test(<span class="hljs-string">'does not drink something octopus-flavored'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> drink = jest.fn();
    drinkAll(drink, <span class="hljs-string">'octopus'</span>);
    expect(drink).not.toHaveBeenCalled();
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tohavebeencalledtimesnumber"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tohavebeencalledtimesnumber" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenCalledTimes(number)</code></h3>
<p>Use <code>.toHaveBeenCalledTimes</code> to ensure that a mock function got called exact
number of times.</p>
<p>For example, let's say you have a <code>drinkEach(drink, Array&lt;flavor&gt;)</code> function
that takes a <code>drink</code> function and applies it to array of passed beverages. You
might want to check that drink function was called exact number of times. You
can do that with this test suite:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'drinkEach drinks each drink'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> drink = jest.fn();
  drinkEach(drink, [<span class="hljs-string">'lemon'</span>, <span class="hljs-string">'octopus'</span>]);
  expect(drink).toHaveBeenCalledTimes(<span class="hljs-number">2</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tohavebeencalledwitharg1-arg2-"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tohavebeencalledwitharg1-arg2-" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenCalledWith(arg1, arg2, ...)</code></h3>
<p>Also under the alias: <code>.toBeCalledWith()</code></p>
<p>Use <code>.toHaveBeenCalledWith</code> to ensure that a mock function was called with
specific arguments.</p>
<p>For example, let's say that you can register a beverage with a <code>register</code>
function, and <code>applyToAll(f)</code> should apply the function <code>f</code> to all registered
beverages. To make sure this works, you could write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'registration applies correctly to orange La Croix'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> beverage = <span class="hljs-keyword">new</span> LaCroix(<span class="hljs-string">'orange'</span>);
  register(beverage);
  <span class="hljs-keyword">const</span> f = jest.fn();
  applyToAll(f);
  expect(f).toHaveBeenCalledWith(beverage);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tohavebeenlastcalledwitharg1-arg2-"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tohavebeenlastcalledwitharg1-arg2-" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenLastCalledWith(arg1, arg2, ...)</code></h3>
<p>Also under the alias: <code>.lastCalledWith(arg1, arg2, ...)</code></p>
<p>If you have a mock function, you can use <code>.toHaveBeenLastCalledWith</code> to test
what arguments it was last called with. For example, let's say you have a
<code>applyToAllFlavors(f)</code> function that applies <code>f</code> to a bunch of flavors, and you
want to ensure that when you call it, the last flavor it operates on is
<code>'mango'</code>. You can write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'applying to all flavors does mango last'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> drink = jest.fn();
  applyToAllFlavors(drink);
  expect(drink).toHaveBeenLastCalledWith(<span class="hljs-string">'mango'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobeclosetonumber-numdigits"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tobeclosetonumber-numdigits" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeCloseTo(number, numDigits)</code></h3>
<p>Using exact equality with floating point numbers is a bad idea. Rounding means
that intuitive things fail. For example, this test fails:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'adding works sanely with simple decimals'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBe(<span class="hljs-number">0.3</span>); <span class="hljs-comment">// Fails!</span>
});
</code></pre>
<p>It fails because in JavaScript, <code>0.2 + 0.1</code> is actually <code>0.30000000000000004</code>.
Sorry.</p>
<p>Instead, use <code>.toBeCloseTo</code>. Use <code>numDigits</code> to control how many digits after
the decimal point to check. For example, if you want to be sure that <code>0.2 + 0.1</code>
is equal to <code>0.3</code> with a precision of 5 decimal digits, you can use this test:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'adding works sanely with simple decimals'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBeCloseTo(<span class="hljs-number">0.3</span>, <span class="hljs-number">5</span>);
});
</code></pre>
<p>The default for <code>numDigits</code> is 2, which has proved to be a good default in most
cases.</p>
<h3><a class="anchor" aria-hidden="true" name="tobedefined"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tobedefined" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeDefined()</code></h3>
<p>Use <code>.toBeDefined</code> to check that a variable is not undefined. For example, if
you just want to check that a function <code>fetchNewFlavorIdea()</code> returns
<em>something</em>, you can write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'there is a new flavor idea'</span>, () =&gt; {
  expect(fetchNewFlavorIdea()).toBeDefined();
});
</code></pre>
<p>You could write <code>expect(fetchNewFlavorIdea()).not.toBe(undefined)</code>, but it's
better practice to avoid referring to <code>undefined</code> directly in your code.</p>
<h3><a class="anchor" aria-hidden="true" name="tobefalsy"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tobefalsy" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeFalsy()</code></h3>
<p>Use <code>.toBeFalsy</code> when you don't care what a value is, you just want to ensure a
value is false in a boolean context. For example, let's say you have some
application code that looks like:</p>
<pre><code class="hljs css js">drinkSomeLaCroix();
<span class="hljs-keyword">if</span> (!getErrors()) {
  drinkMoreLaCroix();
}
</code></pre>
<p>You may not care what <code>getErrors</code> returns, specifically - it might return
<code>false</code>, <code>null</code>, or <code>0</code>, and your code would still work. So if you want to test
there are no errors after drinking some La Croix, you could write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'drinking La Croix does not lead to errors'</span>, () =&gt; {
  drinkSomeLaCroix();
  expect(getErrors()).toBeFalsy();
});
</code></pre>
<p>In JavaScript, there are six falsy values: <code>false</code>, <code>0</code>, <code>''</code>, <code>null</code>,
<code>undefined</code>, and <code>NaN</code>. Everything else is truthy.</p>
<h3><a class="anchor" aria-hidden="true" name="tobegreaterthannumber"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tobegreaterthannumber" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeGreaterThan(number)</code></h3>
<p>To compare floating point numbers, you can use <code>toBeGreaterThan</code>. For example,
if you want to test that <code>ouncesPerCan()</code> returns a value of more than 10
ounces, write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'ounces per can is more than 10'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeGreaterThan(<span class="hljs-number">10</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobegreaterthanorequalnumber"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tobegreaterthanorequalnumber" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeGreaterThanOrEqual(number)</code></h3>
<p>To compare floating point numbers, you can use <code>toBeGreaterThanOrEqual</code>. For
example, if you want to test that <code>ouncesPerCan()</code> returns a value of at least
12 ounces, write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'ounces per can is at least 12'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeGreaterThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobelessthannumber"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tobelessthannumber" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeLessThan(number)</code></h3>
<p>To compare floating point numbers, you can use <code>toBeLessThan</code>. For example, if
you want to test that <code>ouncesPerCan()</code> returns a value of less than 20 ounces,
write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'ounces per can is less than 20'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeLessThan(<span class="hljs-number">20</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobelessthanorequalnumber"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tobelessthanorequalnumber" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeLessThanOrEqual(number)</code></h3>
<p>To compare floating point numbers, you can use <code>toBeLessThanOrEqual</code>. For
example, if you want to test that <code>ouncesPerCan()</code> returns a value of at most 12
ounces, write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'ounces per can is at most 12'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeLessThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobeinstanceofclass"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tobeinstanceofclass" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeInstanceOf(Class)</code></h3>
<p>Use <code>.toBeInstanceOf(Class)</code> to check that an object is an instance of a class.
This matcher uses <code>instanceof</code> underneath.</p>
<pre><code class="hljs css js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{}

expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(A);
expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}).toBeInstanceOf(<span class="hljs-built_in">Function</span>);
expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(<span class="hljs-built_in">Function</span>); <span class="hljs-comment">// throws</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobenull"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tobenull" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeNull()</code></h3>
<p><code>.toBeNull()</code> is the same as <code>.toBe(null)</code> but the error messages are a bit
nicer. So use <code>.toBeNull()</code> when you want to check that something is null.</p>
<pre><code class="hljs css js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bloop</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

test(<span class="hljs-string">'bloop returns null'</span>, () =&gt; {
  expect(bloop()).toBeNull();
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tobetruthy"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tobetruthy" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeTruthy()</code></h3>
<p>Use <code>.toBeTruthy</code> when you don't care what a value is, you just want to ensure a
value is true in a boolean context. For example, let's say you have some
application code that looks like:</p>
<pre><code class="hljs css js">drinkSomeLaCroix();
<span class="hljs-keyword">if</span> (thirstInfo()) {
  drinkMoreLaCroix();
}
</code></pre>
<p>You may not care what <code>thirstInfo</code> returns, specifically - it might return
<code>true</code> or a complex object, and your code would still work. So if you just want
to test that <code>thirstInfo</code> will be truthy after drinking some La Croix, you could
write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'drinking La Croix leads to having thirst info'</span>, () =&gt; {
  drinkSomeLaCroix();
  expect(thirstInfo()).toBeTruthy();
});
</code></pre>
<p>In JavaScript, there are six falsy values: <code>false</code>, <code>0</code>, <code>''</code>, <code>null</code>,
<code>undefined</code>, and <code>NaN</code>. Everything else is truthy.</p>
<h3><a class="anchor" aria-hidden="true" name="tobeundefined"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tobeundefined" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeUndefined()</code></h3>
<p>Use <code>.toBeUndefined</code> to check that a variable is undefined. For example, if you
want to check that a function <code>bestDrinkForFlavor(flavor)</code> returns <code>undefined</code>
for the <code>'octopus'</code> flavor, because there is no good octopus-flavored drink:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'the best drink for octopus flavor is undefined'</span>, () =&gt; {
  expect(bestDrinkForFlavor(<span class="hljs-string">'octopus'</span>)).toBeUndefined();
});
</code></pre>
<p>You could write <code>expect(bestDrinkForFlavor('octopus')).toBe(undefined)</code>, but
it's better practice to avoid referring to <code>undefined</code> directly in your code.</p>
<h3><a class="anchor" aria-hidden="true" name="tocontainitem"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tocontainitem" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toContain(item)</code></h3>
<p>Use <code>.toContain</code> when you want to check that an item is in an array. For testing
the items in the array, this uses <code>===</code>, a strict equality check. <code>.toContain</code>
can also check whether a string is a substring of another string.</p>
<p>For example, if <code>getAllFlavors()</code> returns an array of flavors and you want to be
sure that <code>lime</code> is in there, you can write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'the flavor list contains lime'</span>, () =&gt; {
  expect(getAllFlavors()).toContain(<span class="hljs-string">'lime'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tocontainequalitem"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tocontainequalitem" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toContainEqual(item)</code></h3>
<p>Use <code>.toContainEqual</code> when you want to check that an item with a specific
structure and values is contained in an array. For testing the items in the
array, this matcher recursively checks the equality of all fields, rather than
checking for object identity.</p>
<pre><code class="hljs css js">describe(<span class="hljs-string">'my beverage'</span>, () =&gt; {
  test(<span class="hljs-string">'is delicious and not sour'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> myBeverage = {<span class="hljs-attr">delicious</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">sour</span>: <span class="hljs-literal">false</span>};
    expect(myBeverages()).toContainEqual(myBeverage);
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="toequalvalue"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#toequalvalue" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toEqual(value)</code></h3>
<p>Use <code>.toEqual</code> when you want to check that two objects have the same value. This
matcher recursively checks the equality of all fields, rather than checking for
object identity—this is also known as "deep equal". For example, <code>toEqual</code> and
<code>toBe</code> behave differently in this test suite, so all the tests pass:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">const</span> can1 = {
  <span class="hljs-attr">flavor</span>: <span class="hljs-string">'grapefruit'</span>,
  <span class="hljs-attr">ounces</span>: <span class="hljs-number">12</span>,
};
<span class="hljs-keyword">const</span> can2 = {
  <span class="hljs-attr">flavor</span>: <span class="hljs-string">'grapefruit'</span>,
  <span class="hljs-attr">ounces</span>: <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'the La Croix cans on my desk'</span>, () =&gt; {
  test(<span class="hljs-string">'have all the same properties'</span>, () =&gt; {
    expect(can1).toEqual(can2);
  });
  test(<span class="hljs-string">'are not the exact same can'</span>, () =&gt; {
    expect(can1).not.toBe(can2);
  });
});
</code></pre>
<blockquote>
<p>Note: <code>.toEqual</code> won't perform a <em>deep equality</em> check for two errors. Only
the <code>message</code> property of an Error is considered for equality. It is
recommended to use the <code>.toThrow</code> matcher for testing against errors.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" name="tohavelengthnumber"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tohavelengthnumber" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveLength(number)</code></h3>
<p>Use <code>.toHaveLength</code> to check that an object has a <code>.length</code> property and it is
set to a certain numeric value.</p>
<p>This is especially useful for checking arrays or strings size.</p>
<pre><code class="hljs css js">expect([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">'abc'</span>).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">''</span>).not.toHaveLength(<span class="hljs-number">5</span>);
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tomatchregexporstring"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tomatchregexporstring" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toMatch(regexpOrString)</code></h3>
<p>Use <code>.toMatch</code> to check that a string matches a regular expression.</p>
<p>For example, you might not know what exactly <code>essayOnTheBestFlavor()</code> returns,
but you know it's a really long string, and the substring <code>grapefruit</code> should be
in there somewhere. You can test this with:</p>
<pre><code class="hljs css js">describe(<span class="hljs-string">'an essay on the best flavor'</span>, () =&gt; {
  test(<span class="hljs-string">'mentions grapefruit'</span>, () =&gt; {
    expect(essayOnTheBestFlavor()).toMatch(<span class="hljs-regexp">/grapefruit/</span>);
    expect(essayOnTheBestFlavor()).toMatch(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'grapefruit'</span>));
  });
});
</code></pre>
<p>This matcher also accepts a string, which it will try to match:</p>
<pre><code class="hljs css js">describe(<span class="hljs-string">'grapefruits are healthy'</span>, () =&gt; {
  test(<span class="hljs-string">'grapefruits are a fruit'</span>, () =&gt; {
    expect(<span class="hljs-string">'grapefruits'</span>).toMatch(<span class="hljs-string">'fruit'</span>);
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tomatchobjectobject"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tomatchobjectobject" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toMatchObject(object)</code></h3>
<p>Use <code>.toMatchObject</code> to check that a JavaScript object matches a subset of the
properties of an object. It will match received objects with properties that are
<strong>not</strong> in the expected object.</p>
<p>You can also pass an array of objects, in which case the method will return true
only if each object in the received array matches (in the <code>toMatchObject</code> sense
described above) the corresponding object in the expected array. This is useful
if you want to check that two arrays match in their number of elements, as
opposed to <code>arrayContaining</code>, which allows for extra elements in the received
array.</p>
<p>You can match properties against values or against matchers.</p>
<pre><code class="hljs css js"><span class="hljs-keyword">const</span> houseForSale = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">bedrooms</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">wallColor</span>: <span class="hljs-string">'white'</span>,
  },
};
<span class="hljs-keyword">const</span> desiredHouse = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">wallColor</span>: expect.stringMatching(<span class="hljs-regexp">/white|yellow/</span>),
  },
};

test(<span class="hljs-string">'the house has my desired features'</span>, () =&gt; {
  expect(houseForSale).toMatchObject(desiredHouse);
});
</code></pre>
<pre><code class="hljs css js">describe(<span class="hljs-string">'toMatchObject applied to arrays arrays'</span>, () =&gt; {
  test(<span class="hljs-string">'the number of elements must match exactly'</span>, () =&gt; {
    expect([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}, {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>}]).toMatchObject([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}, {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>}]);
  });

  <span class="hljs-comment">// .arrayContaining "matches a received array which contains elements that</span>
  <span class="hljs-comment">// are *not* in the expected array"</span>
  test(<span class="hljs-string">'.toMatchObject does not allow extra elements'</span>, () =&gt; {
    expect([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}, {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>}]).toMatchObject([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}]);
  });

  test(<span class="hljs-string">'.toMatchObject is called for each elements, so extra object properties are okay'</span>, () =&gt; {
    expect([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}, {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">extra</span>: <span class="hljs-string">'quux'</span>}]).toMatchObject([
      {<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>},
      {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>},
    ]);
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tohavepropertykeypath-value"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tohavepropertykeypath-value" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveProperty(keyPath, value)</code></h3>
<p>Use <code>.toHaveProperty</code> to check if property at provided reference <code>keyPath</code>
exists for an object. For checking deeply nested properties in an object you may
use
<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors">dot notation</a>
or an array containing the keyPath for deep references.</p>
<p>Optionally, you can provide a <code>value</code> to check if it's equal to the value
present at <code>keyPath</code> on the target object. This matcher uses 'deep equality'
(like <code>toEqual()</code>) and recursively checks the equality of all fields.</p>
<p>The following example contains a <code>houseForSale</code> object with nested properties.
We are using <code>toHaveProperty</code> to check for the existence and values of various
properties in the object.</p>
<pre><code class="hljs css js"><span class="hljs-comment">// Object containing house features to be tested</span>
<span class="hljs-keyword">const</span> houseForSale = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">bedrooms</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">wallColor</span>: <span class="hljs-string">'white'</span>,
    <span class="hljs-string">'nice.oven'</span>: <span class="hljs-literal">true</span>,
  },
};

test(<span class="hljs-string">'this house has my desired features'</span>, () =&gt; {
  <span class="hljs-comment">// Simple Referencing</span>
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'bath'</span>);
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'bedrooms'</span>, <span class="hljs-number">4</span>);

  expect(houseForSale).not.toHaveProperty(<span class="hljs-string">'pool'</span>);

  <span class="hljs-comment">// Deep referencing using dot notation</span>
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'kitchen.area'</span>, <span class="hljs-number">20</span>);
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'kitchen.amenities'</span>, [
    <span class="hljs-string">'oven'</span>,
    <span class="hljs-string">'stove'</span>,
    <span class="hljs-string">'washer'</span>,
  ]);

  expect(houseForSale).not.toHaveProperty(<span class="hljs-string">'kitchen.open'</span>);

  <span class="hljs-comment">// Deep referencing using an array containing the keyPath</span>
  expect(houseForSale).toHaveProperty([<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'area'</span>], <span class="hljs-number">20</span>);
  expect(houseForSale).toHaveProperty(
    [<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'amenities'</span>],
    [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
  );
  expect(houseForSale).toHaveProperty([<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'amenities'</span>, <span class="hljs-number">0</span>], <span class="hljs-string">'oven'</span>);
  expect(houseForSale).toHaveProperty([<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'nice.oven'</span>]);
  expect(houseForSale).not.toHaveProperty([<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'open'</span>]);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tomatchsnapshotoptionalstring"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tomatchsnapshotoptionalstring" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toMatchSnapshot(optionalString)</code></h3>
<p>This ensures that a value matches the most recent snapshot. Check out
<a href="https://facebook.github.io/jest/docs/en/snapshot-testing.html">the Snapshot Testing guide</a> for more information.</p>
<p>You can also specify an optional snapshot name. Otherwise, the name is inferred
from the test.</p>
<p><em>Note: While snapshot testing is most commonly used with React components, any
serializable value can be used as a snapshot.</em></p>
<h3><a class="anchor" aria-hidden="true" name="tothrowerror"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tothrowerror" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toThrow(error)</code></h3>
<p>Also under the alias: <code>.toThrowError(error)</code></p>
<p>Use <code>.toThrow</code> to test that a function throws when it is called. For example, if
we want to test that <code>drinkFlavor('octopus')</code> throws, because octopus flavor is
too disgusting to drink, we could write:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }).toThrow();
});
</code></pre>
<p>If you want to test that a specific error gets thrown, you can provide an
argument to <code>toThrow</code>. The argument can be a string for the error message, a
class for the error, or a regex that should match the error. For example, let's
say that <code>drinkFlavor</code> is coded like this:</p>
<pre><code class="hljs css js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkFlavor</span>(<span class="hljs-params">flavor</span>) </span>{
  <span class="hljs-keyword">if</span> (flavor == <span class="hljs-string">'octopus'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisgustingFlavorError(<span class="hljs-string">'yuck, octopus flavor'</span>);
  }
  <span class="hljs-comment">// Do some other stuff</span>
}
</code></pre>
<p>We could test this error gets thrown in several ways:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkOctopus</span>(<span class="hljs-params"></span>) </span>{
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }

  <span class="hljs-comment">// Test the exact error message</span>
  expect(drinkOctopus).toThrowError(<span class="hljs-string">'yuck, octopus flavor'</span>);

  <span class="hljs-comment">// Test that the error message says "yuck" somewhere</span>
  expect(drinkOctopus).toThrowError(<span class="hljs-regexp">/yuck/</span>);

  <span class="hljs-comment">// Test that we get a DisgustingFlavorError</span>
  expect(drinkOctopus).toThrowError(DisgustingFlavorError);
});
</code></pre>
<blockquote>
<p>Note: You must wrap the code in a function, otherwise the error will not be
caught and the assertion will fail.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" name="tothrowerrormatchingsnapshot"></a><a href="https://facebook.github.io/jest/docs/en/expect.html#tothrowerrormatchingsnapshot" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toThrowErrorMatchingSnapshot()</code></h3>
<p>Use <code>.toThrowErrorMatchingSnapshot</code> to test that a function throws an error
matching the most recent snapshot when it is called. For example, let's say you
have a <code>drinkFlavor</code> function that throws whenever the flavor is <code>'octopus'</code>,
and is coded like this:</p>
<pre><code class="hljs css js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkFlavor</span>(<span class="hljs-params">flavor</span>) </span>{
  <span class="hljs-keyword">if</span> (flavor == <span class="hljs-string">'octopus'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisgustingFlavorError(<span class="hljs-string">'yuck, octopus flavor'</span>);
  }
  <span class="hljs-comment">// Do some other stuff</span>
}
</code></pre>
<p>The test for this function will look this way:</p>
<pre><code class="hljs css js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkOctopus</span>(<span class="hljs-params"></span>) </span>{
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }

  expect(drinkOctopus).toThrowErrorMatchingSnapshot();
});
</code></pre>
<p>And it will generate the following snapshot:</p>
<pre><code class="hljs css js">exports[<span class="hljs-string">`drinking flavors throws on octopus 1`</span>] = <span class="hljs-string">`"yuck, octopus flavor"`</span>;
</code></pre>
<p>Check out
<a href="http://facebook.github.io/jest/blog/2016/07/27/jest-14.html">React Tree Snapshot Testing</a>
for more information on snapshot testing.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="https://facebook.github.io/jest/docs/en/api.html">← Globals</a><a class="docs-next button" href="https://facebook.github.io/jest/docs/en/mock-function-api.html">Mock Functions →</a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="https://facebook.github.io/jest/" class="nav-home"><img src="./Expect · Jest_files/jest-outline.svg" alt="Jest" width="66" height="58"></a><div><h5>Docs</h5><a href="https://facebook.github.io/jest/docs/en/getting-started.html">Getting Started</a><a href="https://facebook.github.io/jest/docs/en/snapshot-testing.html">Guides</a><a href="https://facebook.github.io/jest/docs/en/api.html">API Reference</a></div><div><h5>Community</h5><a href="https://facebook.github.io/jest/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/jestjs" target="_blank">Stack Overflow</a><a href="https://discord.gg/MWRhKCj">Jest Chat</a><a href="https://twitter.com/fbjest" target="_blank">Twitter</a></div><div><h5>More</h5><a href="https://facebook.github.io/jest/blog">Blog</a><a href="https://github.com/facebook/jest">GitHub</a><a class="github-button" href="https://github.com/facebook/jest" data-icon="octicon-star" data-count-href="/facebook/jest/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star facebook/jest on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="./Expect · Jest_files/oss_logo.png" alt="Facebook Open Source" width="170" height="45"></a><section class="copyright">Copyright © 2018 Facebook Inc.</section></footer></div><script type="text/javascript" src="./Expect · Jest_files/docsearch.min.js.download"></script></body></html>